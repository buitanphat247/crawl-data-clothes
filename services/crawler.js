const config = require('../config');
const cache = require('../utils/cache');
const scraper = require('../utils/scraper');

class CrawlerService {
  constructor() {
    this.isCrawling = false;
    this.crawlCompleted = false;
    this.crawlData = [];
  }

  // H√†m crawl d·ªØ li·ªáu ch√≠nh
  async crawlJobs() {
    // Ki·ªÉm tra n·∫øu ƒëang crawl ho·∫∑c ƒë√£ ho√†n th√†nh
    if (this.isCrawling) {
      console.log('‚è≥ ƒêang crawl, vui l√≤ng ch·ªù...');
      return;
    }
    
    if (this.crawlCompleted) {
      console.log('‚úÖ ƒê√£ crawl ho√†n th√†nh, s·ª≠ d·ª•ng d·ªØ li·ªáu cache');
      return;
    }
    
    // Ki·ªÉm tra cache tr∆∞·ªõc
    const cachedData = cache.loadCache();
    if (cachedData) {
      console.log('üì¶ ƒê√£ load d·ªØ li·ªáu t·ª´ cache, kh√¥ng c·∫ßn crawl l·∫°i');
      this.crawlData = cachedData;
      this.crawlCompleted = true;
      return;
    }
    
    this.isCrawling = true;
    
    try {
      console.log('üöÄ B·∫Øt ƒë·∫ßu crawl d·ªØ li·ªáu t·ª´ t·∫•t c·∫£ URLs...');
      console.log(`üì° S·∫Ω crawl ${config.CRAWL_URLS.length} URLs:`);
      config.CRAWL_URLS.forEach((url, index) => {
        console.log(`  ${index + 1}. ${url}`);
      });

      var data = [];
      let allProducts = [];

      // Crawl t·ª´ng URL
      for (let urlIndex = 0; urlIndex < config.CRAWL_URLS.length; urlIndex++) {
        const url = config.CRAWL_URLS[urlIndex];
        console.log(`\nüåê [${urlIndex + 1}/${config.CRAWL_URLS.length}] ƒêang crawl: ${url}`);
        
        try {
          const $ = await scraper.crawlPage(url);
          console.log(`‚úÖ ƒê√£ t·∫£i URL th√†nh c√¥ng!`);

          // L·∫•y s·∫£n ph·∫©m t·ª´ trang n√†y
          console.log('üîç ƒêang parse s·∫£n ph·∫©m...');
          let pageProducts = scraper.getProductsFromHtml($);
          console.log(`üìä T√¨m th·∫•y ${pageProducts.length} s·∫£n ph·∫©m t·ª´ URL n√†y`);

          // Load th√™m trang n·∫øu ƒë∆∞·ª£c c·∫•u h√¨nh
          if (config.MAX_NEXT_PAGES > 0) {
            console.log(`üîÑ ƒêang load th√™m ${config.MAX_NEXT_PAGES} trang ti·∫øp theo...`);
            
            for (let pageNum = 2; pageNum <= config.MAX_NEXT_PAGES + 1; pageNum++) {
              console.log(`üì° ƒêang t·∫£i trang ${pageNum}...`);
              const { $nextPage, newProducts } = await scraper.loadNextPage(pageNum, url);
              
              if (newProducts.length === 0) {
                console.log(`‚ùå Trang ${pageNum} kh√¥ng c√≥ s·∫£n ph·∫©m, d·ª´ng load`);
                break;
              }
              
              // Ki·ªÉm tra tr√πng l·∫∑p
              const existingUrls = pageProducts.map(p => p.url);
              const uniqueNewProducts = newProducts.filter(p => !existingUrls.includes(p.url));
              
              if (uniqueNewProducts.length === 0) {
                console.log(`‚ùå Trang ${pageNum}: T·∫•t c·∫£ s·∫£n ph·∫©m ƒë√£ t·ªìn t·∫°i, d·ª´ng load`);
                break;
              }
              
              pageProducts = pageProducts.concat(uniqueNewProducts);
              console.log(`‚úÖ Trang ${pageNum}: Th√™m ${uniqueNewProducts.length} s·∫£n ph·∫©m m·ªõi (T·ªïng: ${pageProducts.length})`);
              
              // Delay gi·ªØa c√°c request
              if (pageNum <= config.MAX_NEXT_PAGES) {
                console.log('‚è≥ Ch·ªù 1 gi√¢y...');
                await new Promise(resolve => setTimeout(resolve, config.REQUEST_DELAY));
              }
            }
          }

          // Th√™m s·∫£n ph·∫©m t·ª´ URL n√†y v√†o t·ªïng
          allProducts = allProducts.concat(pageProducts);
          console.log(`‚úÖ URL ${urlIndex + 1}: T·ªïng c·ªông ${pageProducts.length} s·∫£n ph·∫©m (T·ªïng t·∫•t c·∫£: ${allProducts.length})`);

        } catch (error) {
          console.error(`‚ùå L·ªói crawl URL ${urlIndex + 1} (${url}):`, error.message);
          // Ti·∫øp t·ª•c v·ªõi URL ti·∫øp theo
        }

        // Delay gi·ªØa c√°c URLs
        if (urlIndex < config.CRAWL_URLS.length - 1) {
          console.log('‚è≥ Ch·ªù 2 gi√¢y tr∆∞·ªõc URL ti·∫øp theo...');
          await new Promise(resolve => setTimeout(resolve, 2000));
        }
      }

      console.log(`üéØ T·ªïng c·ªông: ${allProducts.length} s·∫£n ph·∫©m`);

      // C·∫•u h√¨nh s·ªë s·∫£n ph·∫©m crawl
      const productsToCrawl = config.TEST_MODE ? allProducts.slice(0, config.MAX_PRODUCTS) : allProducts;
      console.log(`üß™ ${config.TEST_MODE ? 'Test mode' : 'Production mode'}: Crawl ${productsToCrawl.length}/${allProducts.length} s·∫£n ph·∫©m`);

      // ƒêi s√¢u v√†o t·ª´ng s·∫£n ph·∫©m tu·∫ßn t·ª±
      for (let i = 0; i < productsToCrawl.length; i++) {
        const product = productsToCrawl[i];
        
        console.log(`üîç [${i + 1}/${productsToCrawl.length}] ƒêang crawl: ${product.title.substring(0, 50)}...`);

        if (product.url) {
          const productDetails = await scraper.crawlProductDetails(product.url);
          
          if (productDetails) {
            data.push({
              ...product,
              ...productDetails
            });
            console.log(`‚úÖ [${i + 1}/${productsToCrawl.length}] Crawl th√†nh c√¥ng: ${product.title.substring(0, 30)}...`);
          } else {
            data.push({ ...product, status: 'L·ªói khi crawl chi ti·∫øt' });
            console.log(`‚ùå [${i + 1}/${productsToCrawl.length}] Crawl th·∫•t b·∫°i: ${product.title.substring(0, 30)}...`);
          }
        } else {
          console.log(`‚ö†Ô∏è [${i + 1}/${productsToCrawl.length}] Kh√¥ng c√≥ URL ƒë·ªÉ crawl`);
          data.push({ ...product, status: 'Kh√¥ng c√≥ URL' });
        }
      }

      // L∆∞u d·ªØ li·ªáu
      this.crawlData = data;
      this.crawlCompleted = true;
      
      // L∆∞u cache
      cache.saveCache(data);

      console.log(`üéâ Ho√†n th√†nh crawl d·ªØ li·ªáu! T·ªïng: ${data.length} s·∫£n ph·∫©m`);
      
      // Click n√∫t "Xem th√™m s·∫£n ph·∫©m" sau khi crawl xong (n·∫øu ch∆∞a load ƒë·ªß trang)
      if (config.MAX_NEXT_PAGES === 0) {
        await this.handleLoadMoreButton($);
      }
      
      // Hi·ªÉn th·ªã k·∫øt qu·∫£ cu·ªëi c√πng
      console.log('\nüéØ ===== K·∫æT TH√öC CRAWL =====');
      console.log(`üìä T·ªïng s·∫£n ph·∫©m ƒë√£ crawl: ${data.length}`);
      console.log(`‚è∞ Th·ªùi gian ho√†n th√†nh: ${new Date().toLocaleString('vi-VN')}`);
      console.log('üåê Server ƒëang ch·∫°y t·∫°i: http://localhost:3000');
      
    } catch (error) {
      console.log(`‚ùå L·ªói crawl: ${error.message}`);
    } finally {
      this.isCrawling = false;
    }
  }

  // X·ª≠ l√Ω n√∫t "Xem th√™m s·∫£n ph·∫©m"
  async handleLoadMoreButton($) {
    console.log('üîÑ ƒêang click n√∫t "Xem th√™m s·∫£n ph·∫©m"...');
    try {
      const loadMoreBtn = $('.btn-loadmore');
      
      if (loadMoreBtn.length > 0) {
        const dataPage = loadMoreBtn.attr('data-page');
        console.log(`üì° ƒêang t·∫£i trang ${dataPage}...`);
        
        const { $nextPage, newProducts } = await scraper.loadNextPage(dataPage);
        
        if (newProducts.length > 0) {
          console.log('‚úÖ Click th√†nh c√¥ng - C√≥ s·∫£n ph·∫©m m·ªõi ƒë∆∞·ª£c load');
          
          // Crawl th·ª≠ 1 s·∫£n ph·∫©m c·ªßa trang ti·∫øp theo
          console.log('üîç ƒêang crawl th·ª≠ 1 s·∫£n ph·∫©m trang ti·∫øp theo...');
          
          const firstProduct = $nextPage('.product-loop').first();
          const nextProductTitle = firstProduct.find('.proloop-detail h3 a').text().trim();
          const nextProductUrl = firstProduct.find('.proloop-link').attr('href');
          const nextProductFullUrl = nextProductUrl ? `${config.BASE_URL}${nextProductUrl}` : null;
          
          if (nextProductFullUrl) {
            const productDetails = await scraper.crawlProductDetails(nextProductFullUrl);
            
            if (productDetails) {
              const newProduct = {
                title: nextProductTitle,
                url: nextProductFullUrl,
                ...productDetails
              };
              
              this.crawlData.push(newProduct);
              
              console.log(`‚úÖ ƒê√£ th√™m s·∫£n ph·∫©m m·ªõi! T·ªïng: ${this.crawlData.length} s·∫£n ph·∫©m`);
            } else {
              console.log('‚ùå Kh√¥ng th·ªÉ crawl s·∫£n ph·∫©m m·ªõi');
            }
          } else {
            console.log('‚ö†Ô∏è Kh√¥ng c√≥ URL s·∫£n ph·∫©m ƒë·ªÉ crawl');
          }
        } else {
          console.log('‚ö†Ô∏è Click th√†nh c√¥ng nh∆∞ng kh√¥ng c√≥ s·∫£n ph·∫©m m·ªõi');
        }
      } else {
        console.log('‚ùå Kh√¥ng t√¨m th·∫•y n√∫t "Xem th√™m s·∫£n ph·∫©m"');
      }
    } catch (error) {
      console.log(`‚ùå L·ªói khi click n√∫t "Xem th√™m s·∫£n ph·∫©m": ${error.message}`);
    }
  }

  // Force crawl l·∫°i
  async forceCrawl() {
    if (this.isCrawling) {
      return { message: 'ƒêang crawl, vui l√≤ng ch·ªù...', isCrawling: true };
    }
    
    // X√≥a cache v√† crawl l·∫°i
    cache.clearCache();
    
    this.crawlCompleted = false;
    this.crawlData = [];
    
    // B·∫Øt ƒë·∫ßu crawl l·∫°i
    this.crawlJobs();
    
    return { message: 'ƒê√£ b·∫Øt ƒë·∫ßu crawl l·∫°i...', isCrawling: true };
  }

  // L·∫•y d·ªØ li·ªáu
  getData() {
    return this.crawlData;
  }

  // L·∫•y tr·∫°ng th√°i
  getStatus() {
    return {
      isCrawling: this.isCrawling,
      crawlCompleted: this.crawlCompleted,
      dataCount: this.crawlData.length,
      hasCache: cache.hasCache()
    };
  }
}

module.exports = new CrawlerService();
